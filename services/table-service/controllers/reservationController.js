const { DatBan, Ban } = require('../models');
const { Op, Sequelize } = require('sequelize');
const { sequelize } = require('../config/database');

// Helper function to update table status based on reservations
const updateTableStatusBasedOnReservations = async (MaBan, currentAction = null) => {
  try {
    const today = new Date().toISOString().split('T')[0];
    
    // T√¨m t·∫•t c·∫£ ƒë·∫∑t b√†n active cho b√†n n√†y trong ng√†y h√¥m nay
    const activeReservations = await DatBan.findAll({
      where: {
        MaBan,
        NgayDat: today,
        TrangThai: ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n']
      }
    });

    const table = await Ban.findByPk(MaBan);
    if (!table) return;

    // Logic c·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n:
    // - N·∫øu c√≥ √≠t nh·∫•t 1 ƒë∆°n ƒë·∫∑t b√†n ·ªü tr·∫°ng th√°i "ƒê√£ ƒë·∫∑t" ho·∫∑c "ƒê√£ x√°c nh·∫≠n" ‚Üí B√†n = "ƒê√£ ƒë·∫∑t"
    // - N·∫øu kh√¥ng c√≥ ƒë∆°n ƒë·∫∑t b√†n n√†o active ‚Üí B√†n = "Tr·ªëng"
    
    if (activeReservations.length > 0) {
      // C√≥ ƒë·∫∑t b√†n active ‚Üí b√†n ·ªü tr·∫°ng th√°i "ƒê√£ ƒë·∫∑t"
      if (table.TrangThai !== 'ƒê√£ ƒë·∫∑t') {
        await table.update({ TrangThai: 'ƒê√£ ƒë·∫∑t' });
        console.log(`üìã Updated table ${MaBan} status to "ƒê√£ ƒë·∫∑t" (${activeReservations.length} active reservations)`);
      }
    } else {
      // Kh√¥ng c√≥ ƒë·∫∑t b√†n active ‚Üí b√†n tr·ªëng
      if (table.TrangThai !== 'Tr·ªëng') {
        await table.update({ TrangThai: 'Tr·ªëng' });
        console.log(`üìã Updated table ${MaBan} status to "Tr·ªëng" (no active reservations)`);
      }
    }
  } catch (error) {
    console.error('Error updating table status:', error);
  }
};

// L·∫•y t·∫•t c·∫£ ƒë·∫∑t b√†n v·ªõi b·ªô l·ªçc
const getReservations = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      MaBan,
      TrangThai,
      NgayDat,
      start_date,
      end_date
    } = req.query;

    const offset = (page - 1) * limit;
    const whereClause = {};

    // √Åp d·ª•ng b·ªô l·ªçc
    if (MaBan) whereClause.MaBan = MaBan;
    if (TrangThai) whereClause.TrangThai = TrangThai;
    
    if (NgayDat) {
      whereClause.NgayDat = NgayDat;
    } else if (start_date || end_date) {
      whereClause.NgayDat = {};
      if (start_date) whereClause.NgayDat[Op.gte] = start_date;
      if (end_date) whereClause.NgayDat[Op.lte] = end_date;
    }

    const { count, rows } = await DatBan.findAndCountAll({
      where: whereClause,
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }],
      order: [['NgayDat', 'DESC'], ['GioDat', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset)
    });

    res.json({
      success: true,
      data: {
        reservations: rows,
        pagination: {
          current_page: parseInt(page),
          total_pages: Math.ceil(count / limit),
          total_items: count,
          items_per_page: parseInt(limit)
        }
      }
    });

  } catch (error) {
    console.error('Error fetching reservations:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// L·∫•y ƒë·∫∑t b√†n theo ID
const getReservationById = async (req, res) => {
  try {
    const { id } = req.params;

    const reservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }]
    });

    if (!reservation) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n'
      });
    }

    res.json({
      success: true,
      data: { reservation }
    });

  } catch (error) {
    console.error('Error fetching reservation:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// T·∫°o ƒë·∫∑t b√†n m·ªõi
const createReservation = async (req, res) => {
  try {
    console.log('üìù Creating reservation with data:', req.body);
    
    const {
      MaKH,
      MaBan,
      NgayDat,
      GioDat,
      GioKetThuc,
      SoNguoi,
      TenKhach,
      SoDienThoai,
      EmailKhach,
      GhiChu
    } = req.body;

    // Sanitize time values - handle arrays and strings
    const cleanGioDat = Array.isArray(GioDat) ? GioDat[0] : (typeof GioDat === 'string' ? GioDat.trim().split(',')[0] : GioDat);
    const cleanGioKetThuc = Array.isArray(GioKetThuc) ? GioKetThuc[0] : (typeof GioKetThuc === 'string' ? GioKetThuc.trim().split(',')[0] : GioKetThuc);
    
    console.log('üßπ Original reservation values:', { GioDat, GioKetThuc });
    console.log('üßπ Cleaned reservation time values:', { cleanGioDat, cleanGioKetThuc });

    // Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc c∆° b·∫£n
    if (!MaBan || !NgayDat || !GioDat || !GioKetThuc || !SoNguoi || !TenKhach || !SoDienThoai) {
      return res.status(400).json({
        success: false,
        error: 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc: MaBan, NgayDat, GioDat, GioKetThuc, SoNguoi, TenKhach, SoDienThoai'
      });
    }

    // Ki·ªÉm tra th·ªùi gian h·ª£p l·ªá (ch·ªâ khi c√≥ GioKetThuc)
    if (cleanGioKetThuc && cleanGioDat >= cleanGioKetThuc) {
      return res.status(400).json({
        success: false,
        error: 'Gi·ªù k·∫øt th√∫c ph·∫£i sau gi·ªù b·∫Øt ƒë·∫ßu'
      });
    }

    // Ki·ªÉm tra b√†n c√≥ t·ªìn t·∫°i kh√¥ng
    console.log('üîç Looking for table with ID:', MaBan);
    const table = await Ban.findByPk(MaBan);
    console.log('üìã Found table:', table ? table.toJSON() : 'null');
    
    if (!table) {
      return res.status(400).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y b√†n'
      });
    }

    // Ki·ªÉm tra s·ªë ng∆∞·ªùi c√≥ v∆∞·ª£t qu√° s·ª©c ch·ª©a kh√¥ng
    if (SoNguoi > table.SoCho) {
      return res.status(400).json({
        success: false,
        error: `S·ªë ng∆∞·ªùi (${SoNguoi}) v∆∞·ª£t qu√° s·ª©c ch·ª©a c·ªßa b√†n (${table.SoCho})`
      });
    }

    // Ki·ªÉm tra xem c·ªôt GioKetThuc c√≥ t·ªìn t·∫°i kh√¥ng
    let hasGioKetThucColumn = false;
    try {
      await sequelize.query("SELECT GioKetThuc FROM DatBan LIMIT 1");
      hasGioKetThucColumn = true;
    } catch (error) {
      console.log('‚ö†Ô∏è GioKetThuc column not found, using fallback logic');
      hasGioKetThucColumn = false;
    }

    let conflictingReservations;
    
    if (hasGioKetThucColumn && cleanGioKetThuc) {
      // Logic v·ªõi kho·∫£ng th·ªùi gian (khi c√≥ c·ªôt GioKetThuc)
      conflictingReservations = await DatBan.findAll({
        where: {
          MaBan,
          NgayDat,
          TrangThai: ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n'],
          [Op.or]: [
            // Tr∆∞·ªùng h·ª£p 1: Th·ªùi gian b·∫Øt ƒë·∫ßu m·ªõi n·∫±m trong kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.lte]: cleanGioDat },
              GioKetThuc: { [Op.gt]: cleanGioDat }
            },
            // Tr∆∞·ªùng h·ª£p 2: Th·ªùi gian k·∫øt th√∫c m·ªõi n·∫±m trong kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.lt]: cleanGioKetThuc },
              GioKetThuc: { [Op.gte]: cleanGioKetThuc }
            },
            // Tr∆∞·ªùng h·ª£p 3: Kho·∫£ng th·ªùi gian m·ªõi bao tr√πm kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.gte]: cleanGioDat },
              GioKetThuc: { [Op.lte]: cleanGioKetThuc }
            }
          ]
        }
      });
    } else {
      // Logic fallback (ch·ªâ ki·ªÉm tra gi·ªù b·∫Øt ƒë·∫ßu tr√πng nhau)
      conflictingReservations = await DatBan.findOne({
        where: {
          MaBan,
          NgayDat,
          GioDat: cleanGioDat,
          TrangThai: ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n']
        }
      });
      conflictingReservations = conflictingReservations ? [conflictingReservations] : [];
    }

    if (conflictingReservations.length > 0) {
      const conflictDetails = conflictingReservations.map(r => ({
        MaDat: r.MaDat,
        GioDat: r.GioDat,
        GioKetThuc: r.GioKetThuc || 'N/A',
        TenKhach: r.TenKhach
      }));
      
      return res.status(400).json({
        success: false,
        error: 'B√†n ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t trong kho·∫£ng th·ªùi gian n√†y',
        conflicting_reservations: conflictDetails
      });
    }

    // S·ª≠ d·ª•ng stored procedure ƒë·ªÉ ki·ªÉm tra to√†n di·ªán
    console.log('üîç Validating reservation with database functions...');
    // try {
    //   const [validationResult] = await sequelize.query(
    //     `SELECT KiemTraToanDienDatBan(?, ?, ?, ?, ?, ?, ?, ?, ?) as isValid`,
    //     {
    //       replacements: [
    //         MaKH || null,
    //         MaBan,
    //         NgayDat,
    //         cleanGioDat,
    //         cleanGioKetThuc,
    //         parseInt(SoNguoi),
    //         TenKhach ? TenKhach.trim() : '',
    //         SoDienThoai ? SoDienThoai.trim() : '',
    //         EmailKhach ? EmailKhach.trim() : null
    //       ]
    //     }
    //   );

    //   if (!validationResult[0]?.isValid) {
    //     return res.status(400).json({
    //       success: false,
    //       error: 'D·ªØ li·ªáu ƒë·∫∑t b√†n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin.',
    //       details: 'Validation failed by database function'
    //     });
    //   }
    // } catch (validationError) {
      console.log('‚ö†Ô∏è Database validation function not available, using basic validation');
    // }

    // T·∫°o ƒë·∫∑t b√†n
    console.log('üîÑ Creating reservation in database...');
    const reservationData = {
      MaKH: MaKH || null,
      MaBan,
      NgayDat,
      GioDat: cleanGioDat,
      GioKetThuc: cleanGioKetThuc,
      SoNguoi: parseInt(SoNguoi),
      TrangThai: 'ƒê√£ ƒë·∫∑t',
      TenKhach: TenKhach ? TenKhach.trim() : '',
      SoDienThoai: SoDienThoai ? SoDienThoai.trim() : '',
      EmailKhach: EmailKhach ? EmailKhach.trim() : null,
      GhiChu: GhiChu ? GhiChu.trim() : null,
      NgayTaoDat: new Date(),
      MaNVXuLy: req.user?.MaNV || null // From auth middleware
    };
    
    console.log('üìã Reservation data to create:', reservationData);
    const reservation = await DatBan.create(reservationData);
    console.log('‚úÖ Reservation created with ID:', reservation.MaDat);

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n d·ª±a tr√™n ƒë·∫∑t b√†n m·ªõi
    await updateTableStatusBasedOnReservations(MaBan, 'created');

    const createdReservation = await DatBan.findByPk(reservation.MaDat, {
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }]
    });

    res.status(201).json({
      success: true,
      message: 'ƒê·∫∑t b√†n th√†nh c√¥ng',
      data: { reservation: createdReservation }
    });

  } catch (error) {
    console.error('Error creating reservation:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ t·∫°o ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// C·∫≠p nh·∫≠t ƒë·∫∑t b√†n
const updateReservation = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const reservation = await DatBan.findByPk(id);
    if (!reservation) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n'
      });
    }

    // Kh√¥ng cho ph√©p c·∫≠p nh·∫≠t ƒë·∫∑t b√†n ƒë√£ ho√†n th√†nh ho·∫∑c ƒë√£ h·ªßy
    if (['Ho√†n th√†nh', 'ƒê√£ h·ªßy'].includes(reservation.TrangThai)) {
      return res.status(400).json({
        success: false,
        error: `Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ƒë·∫∑t b√†n ƒë√£ ${reservation.TrangThai}`
      });
    }

    // N·∫øu c·∫≠p nh·∫≠t MaBan, ki·ªÉm tra b√†n m·ªõi
    if (updateData.MaBan && updateData.MaBan !== reservation.MaBan) {
      const newTable = await Ban.findByPk(updateData.MaBan);
      if (!newTable) {
        return res.status(400).json({
          success: false,
          error: 'Kh√¥ng t√¨m th·∫•y b√†n m·ªõi'
        });
      }

      // Ki·ªÉm tra s·ªë ng∆∞·ªùi v·ªõi s·ª©c ch·ª©a b√†n m·ªõi
      const soNguoi = updateData.SoNguoi || reservation.SoNguoi;
      if (soNguoi > newTable.SoCho) {
        return res.status(400).json({
          success: false,
          error: `S·ªë ng∆∞·ªùi (${soNguoi}) v∆∞·ª£t qu√° s·ª©c ch·ª©a b√†n m·ªõi (${newTable.SoCho})`
        });
      }
    }

    await reservation.update(updateData);

    const updatedReservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }]
    });

    res.json({
      success: true,
      message: 'C·∫≠p nh·∫≠t ƒë·∫∑t b√†n th√†nh c√¥ng',
      data: { reservation: updatedReservation }
    });

  } catch (error) {
    console.error('Error updating reservation:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë·∫∑t b√†n
const updateReservationStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { TrangThai, GhiChu } = req.body;

    if (!TrangThai) {
      return res.status(400).json({
        success: false,
        error: 'Tr·∫°ng th√°i l√† b·∫Øt bu·ªôc'
      });
    }

    const validStatuses = ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n', 'ƒê√£ h·ªßy', 'Ho√†n th√†nh'];
    if (!validStatuses.includes(TrangThai)) {
      return res.status(400).json({
        success: false,
        error: 'Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá'
      });
    }

    const reservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban'
      }]
    });

    if (!reservation) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n'
      });
    }

    const updateData = { TrangThai };
    if (GhiChu) updateData.GhiChu = GhiChu;

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n d·ª±a tr√™n tr·∫°ng th√°i ƒë·∫∑t b√†n
    await updateTableStatusBasedOnReservations(reservation.MaBan, TrangThai);

    await reservation.update(updateData);

    const updatedReservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }]
    });

    res.json({
      success: true,
      message: `C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë·∫∑t b√†n th√†nh ${TrangThai}`,
      data: { reservation: updatedReservation }
    });

  } catch (error) {
    console.error('Error updating reservation status:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// H·ªßy ƒë·∫∑t b√†n
const cancelReservation = async (req, res) => {
  try {
    const { id } = req.params;
    const { GhiChu } = req.body;

    const reservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban'
      }]
    });

    if (!reservation) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n'
      });
    }

    if (['Ho√†n th√†nh', 'ƒê√£ h·ªßy'].includes(reservation.TrangThai)) {
      return res.status(400).json({
        success: false,
        error: `Kh√¥ng th·ªÉ h·ªßy ƒë·∫∑t b√†n ƒë√£ ${reservation.TrangThai}`
      });
    }

    await reservation.update({
      TrangThai: 'ƒê√£ h·ªßy',
      GhiChu: GhiChu || reservation.GhiChu
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n d·ª±a tr√™n t·∫•t c·∫£ ƒë·∫∑t b√†n
    await updateTableStatusBasedOnReservations(reservation.MaBan, 'ƒê√£ h·ªßy');

    res.json({
      success: true,
      message: 'H·ªßy ƒë·∫∑t b√†n th√†nh c√¥ng',
      data: { reservation }
    });

  } catch (error) {
    console.error('Error cancelling reservation:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ h·ªßy ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// X√≥a ƒë·∫∑t b√†n ho√†n to√†n
const deleteReservation = async (req, res) => {
  try {
    const { id } = req.params;

    const reservation = await DatBan.findByPk(id, {
      include: [{
        model: Ban,
        as: 'ban'
      }]
    });

    if (!reservation) {
      return res.status(404).json({
        success: false,
        error: 'Kh√¥ng t√¨m th·∫•y ƒë·∫∑t b√†n'
      });
    }

    const tableMaBan = reservation.MaBan;
    
    // X√≥a ƒë·∫∑t b√†n kh·ªèi database
    await reservation.destroy();

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i b√†n d·ª±a tr√™n t·∫•t c·∫£ ƒë·∫∑t b√†n c√≤n l·∫°i
    await updateTableStatusBasedOnReservations(tableMaBan, 'deleted');

    res.json({
      success: true,
      message: 'X√≥a ƒë·∫∑t b√†n th√†nh c√¥ng'
    });

  } catch (error) {
    console.error('Error deleting reservation:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ x√≥a ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

// L·∫•y ƒë·∫∑t b√†n h√¥m nay
const getTodayReservations = async (req, res) => {
  try {
    const today = new Date().toISOString().split('T')[0];
    const { TrangThai } = req.query;

    const whereClause = {
      NgayDat: today
    };

    if (TrangThai) {
      whereClause.TrangThai = TrangThai;
    }

    const reservations = await DatBan.findAll({
      where: whereClause,
      include: [{
        model: Ban,
        as: 'ban',
        attributes: ['MaBan', 'TenBan', 'SoCho', 'TrangThai']
      }],
      order: [['GioDat', 'ASC']]
    });

    res.json({
      success: true,
      data: {
        date: today,
        reservations
      }
    });

  } catch (error) {
    console.error('Error fetching today reservations:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch ƒë·∫∑t b√†n h√¥m nay',
      message: error.message
    });
  }
};

// L·∫•y b√†n tr·ªëng theo th·ªùi gian
const getAvailableTables = async (req, res) => {
  try {
    const { NgayDat, GioDat, GioKetThuc, SoNguoi } = req.query;
    
    console.log('üîç getAvailableTables query params:', { NgayDat, GioDat, GioKetThuc, SoNguoi });

    if (!NgayDat || !GioDat || !SoNguoi) {
      return res.status(400).json({
        success: false,
        error: 'Thi·∫øu th√¥ng tin: NgayDat, GioDat, SoNguoi'
      });
    }

    // Sanitize time values - handle arrays and strings
    const cleanGioDat = Array.isArray(GioDat) ? GioDat[0] : (typeof GioDat === 'string' ? GioDat.trim().split(',')[0] : GioDat);
    const cleanGioKetThuc = Array.isArray(GioKetThuc) ? GioKetThuc[0] : (typeof GioKetThuc === 'string' ? GioKetThuc.trim().split(',')[0] : GioKetThuc);
    
    console.log('üßπ Original values:', { GioDat, GioKetThuc });
    console.log('üßπ Cleaned time values:', { cleanGioDat, cleanGioKetThuc });

    // Ki·ªÉm tra th·ªùi gian h·ª£p l·ªá (ch·ªâ khi c√≥ GioKetThuc)
    if (cleanGioKetThuc && cleanGioDat >= cleanGioKetThuc) {
      return res.status(400).json({
        success: false,
        error: 'Gi·ªù k·∫øt th√∫c ph·∫£i sau gi·ªù b·∫Øt ƒë·∫ßu'
      });
    }

    // L·∫•y t·∫•t c·∫£ b√†n c√≥ s·ª©c ch·ª©a ph√π h·ª£p
    const allTables = await Ban.findAll({
      where: {
        SoCho: { [Op.gte]: parseInt(SoNguoi) },
        TrangThai: { [Op.ne]: 'B·∫£o tr√¨' }
      }
    });

    // Ki·ªÉm tra xem c·ªôt GioKetThuc c√≥ t·ªìn t·∫°i kh√¥ng
    let hasGioKetThucColumn = false;
    try {
      await sequelize.query("SELECT GioKetThuc FROM DatBan LIMIT 1");
      hasGioKetThucColumn = true;
    } catch (error) {
      console.log('‚ö†Ô∏è GioKetThuc column not found, using fallback logic');
      hasGioKetThucColumn = false;
    }

    let reservedTables;
    
    if (hasGioKetThucColumn && cleanGioKetThuc) {
      // Logic v·ªõi kho·∫£ng th·ªùi gian (khi c√≥ c·ªôt GioKetThuc)
      console.log('üîÑ Using time range logic with:', { cleanGioDat, cleanGioKetThuc });
      reservedTables = await DatBan.findAll({
        where: {
          NgayDat,
          TrangThai: ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n'],
          [Op.or]: [
            // Tr∆∞·ªùng h·ª£p 1: Th·ªùi gian b·∫Øt ƒë·∫ßu m·ªõi n·∫±m trong kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.lte]: cleanGioDat },
              GioKetThuc: { [Op.gt]: cleanGioDat }
            },
            // Tr∆∞·ªùng h·ª£p 2: Th·ªùi gian k·∫øt th√∫c m·ªõi n·∫±m trong kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.lt]: cleanGioKetThuc },
              GioKetThuc: { [Op.gte]: cleanGioKetThuc }
            },
            // Tr∆∞·ªùng h·ª£p 3: Kho·∫£ng th·ªùi gian m·ªõi bao tr√πm kho·∫£ng th·ªùi gian ƒë√£ ƒë·∫∑t
            {
              GioDat: { [Op.gte]: cleanGioDat },
              GioKetThuc: { [Op.lte]: cleanGioKetThuc }
            }
          ]
        },
        attributes: ['MaBan']
      });
    } else {
      // Logic fallback (ch·ªâ ki·ªÉm tra gi·ªù b·∫Øt ƒë·∫ßu tr√πng nhau)
      console.log('üîÑ Using fallback logic with:', { cleanGioDat });
      reservedTables = await DatBan.findAll({
        where: {
          NgayDat,
          GioDat: cleanGioDat,
          TrangThai: ['ƒê√£ ƒë·∫∑t', 'ƒê√£ x√°c nh·∫≠n']
        },
        attributes: ['MaBan']
      });
    }

    const reservedTableIds = reservedTables.map(r => r.MaBan);
    const availableTables = allTables.filter(table => !reservedTableIds.includes(table.MaBan));

    res.json({
      success: true,
      data: {
        available_tables: availableTables,
        total_available: availableTables.length
      }
    });

  } catch (error) {
    console.error('Error fetching available tables:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch b√†n tr·ªëng',
      message: error.message
    });
  }
};

// Th·ªëng k√™ ƒë·∫∑t b√†n
const getReservationStats = async (req, res) => {
  try {
    const { start_date, end_date } = req.query;
    const whereClause = {};

    if (start_date || end_date) {
      whereClause.NgayDat = {};
      if (start_date) whereClause.NgayDat[Op.gte] = start_date;
      if (end_date) whereClause.NgayDat[Op.lte] = end_date;
    }

    const totalReservations = await DatBan.count({ where: whereClause });
    
    const statusCounts = await DatBan.findAll({
      where: whereClause,
      attributes: [
        'TrangThai',
        [sequelize.fn('COUNT', sequelize.col('MaDat')), 'count']
      ],
      group: ['TrangThai']
    });

    const averagePartySize = await DatBan.findAll({
      where: { ...whereClause, TrangThai: { [Op.ne]: 'ƒê√£ h·ªßy' } },
      attributes: [
        [sequelize.fn('AVG', sequelize.col('SoNguoi')), 'average']
      ]
    });

    res.json({
      success: true,
      data: {
        stats: {
          total_reservations: totalReservations,
          status_breakdown: statusCounts.map(s => ({
            status: s.TrangThai,
            count: parseInt(s.dataValues.count)
          })),
          average_party_size: parseFloat(averagePartySize[0]?.dataValues?.average || 0).toFixed(1)
        }
      }
    });

  } catch (error) {
    console.error('Error fetching reservation stats:', error);
    res.status(500).json({
      success: false,
      error: 'Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™ ƒë·∫∑t b√†n',
      message: error.message
    });
  }
};

module.exports = {
  getReservations,
  getReservationById,
  createReservation,
  updateReservation,
  updateReservationStatus,
  cancelReservation,
  deleteReservation,
  getTodayReservations,
  getAvailableTables,
  getReservationStats
};
